<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Animator | Big Head Billionaires</title>
  <link rel="icon" href="../assets/favicon.png"/>
  <link rel="stylesheet" href="../assets/bhb.css"/>
  <style>
    .page-header {
      margin-top: 62px;
      background: var(--black);
      border-bottom: 4px solid var(--yellow);
      padding: 1.25rem 2rem;
      display: flex; align-items: center; justify-content: space-between;
    }
    .page-header h1 { font-family:var(--font-display); font-size:2rem; color:var(--yellow); letter-spacing:0.06em; line-height:1; }
    .page-header p  { font-family:var(--font-mono); font-size:0.76rem; color:rgba(255,255,255,0.5); margin-top:0.3rem; }

    /* â”€â”€ Main layout â”€â”€ */
    .anim-wrap {
      display: grid;
      grid-template-columns: 1fr 320px;
      height: calc(100vh - 62px - 72px);
      overflow: hidden;
    }

    /* â”€â”€ LEFT: Stage + timeline â”€â”€ */
    .stage-col {
      display: flex; flex-direction: column;
      border-right: 4px solid var(--black);
      overflow: hidden;
    }

    .stage-area {
      flex: 1;
      display: flex; align-items: center; justify-content: center;
      padding: 1.25rem;
      background: repeating-linear-gradient(
        45deg,
        rgba(0,0,0,0.03) 0px, rgba(0,0,0,0.03) 10px,
        transparent 10px, transparent 20px
      );
      overflow: hidden;
    }

    .canvas-wrap {
      position: relative;
      width: min(440px, calc(100vh - 62px - 72px - 180px - 2.5rem));
      height: min(440px, calc(100vh - 62px - 72px - 180px - 2.5rem));
      border: 4px solid var(--black); border-radius: 12px;
      overflow: hidden; box-shadow: var(--shadow-lg);
    }

    #animCanvas { position:absolute; inset:0; width:100%; height:100%; image-rendering:pixelated; }

    /* Loading overlay */
    .load-overlay {
      position:absolute; inset:0;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      background:rgba(13,13,13,0.92); z-index:20; gap:0.9rem;
    }
    .load-title { font-family:var(--font-display); font-size:1.1rem; color:var(--yellow); letter-spacing:0.08em; }
    .load-bar   { width:200px; height:10px; background:rgba(255,255,255,0.1); border:2px solid var(--yellow); border-radius:999px; overflow:hidden; }
    .load-fill  { height:100%; background:var(--yellow); border-radius:999px; transition:width 0.2s; }
    .load-stat  { font-family:var(--font-mono); font-size:0.62rem; color:rgba(255,255,255,0.45); }

    /* No character gate */
    .gate-overlay {
      position:absolute; inset:0;
      display:none; flex-direction:column; align-items:center; justify-content:center;
      background:rgba(13,13,13,0.92); z-index:20; gap:1rem; padding:2rem; text-align:center;
    }
    .gate-overlay.show { display:flex; }
    .gate-title { font-family:var(--font-display); font-size:1.3rem; color:var(--yellow); letter-spacing:0.06em; }
    .gate-sub   { font-family:var(--font-mono); font-size:0.72rem; color:rgba(255,255,255,0.5); line-height:1.6; }
    .gate-btn   {
      font-family:var(--font-display); font-size:0.9rem; letter-spacing:0.06em;
      background:var(--yellow); color:var(--black);
      border:3px solid var(--yellow); border-radius:6px;
      padding:0.6rem 1.4rem; cursor:pointer; text-decoration:none;
      transition:all 0.1s;
    }
    .gate-btn:hover { transform:translate(-2px,-2px); box-shadow:4px 4px 0 var(--yellow); }

    /* BG selector strip */
    .bg-strip {
      background: var(--black);
      border-top: 3px solid var(--black);
      padding: 0.5rem 1rem;
      display: flex; align-items: center; gap: 0.5rem; flex-shrink:0;
    }
    .bg-strip-label { font-family:var(--font-mono); font-size:0.62rem; color:rgba(255,255,255,0.4); letter-spacing:0.08em; text-transform:uppercase; margin-right:0.25rem; }
    .bg-btn {
      padding:0.3rem 0.7rem;
      font-family:var(--font-mono); font-size:0.65rem; letter-spacing:0.06em;
      background:rgba(255,255,255,0.07); color:rgba(255,255,255,0.6);
      border:2px solid rgba(255,255,255,0.15); border-radius:4px;
      cursor:pointer; transition:all 0.1s;
    }
    .bg-btn:hover  { background:rgba(255,255,255,0.15); color:#fff; }
    .bg-btn.active { background:var(--yellow); color:var(--black); border-color:var(--yellow); }

    /* Timeline bar */
    .timeline-bar {
      border-top: 3px solid var(--black);
      background: rgba(0,0,0,0.06);
      padding: 0.75rem 1rem;
      flex-shrink: 0;
    }

    .tl-row { display:flex; align-items:center; gap:0.75rem; margin-bottom:0.5rem; }

    .tl-btn {
      padding:0.35rem 0.7rem;
      font-family:var(--font-display); font-size:0.8rem; letter-spacing:0.06em;
      background:var(--black); color:var(--yellow);
      border:2px solid var(--black); border-radius:4px;
      cursor:pointer; transition:all 0.1s;
    }
    .tl-btn:hover  { background:var(--yellow); color:var(--black); }
    .tl-btn:active { transform:scale(0.95); }
    .tl-btn:disabled { opacity:0.35; cursor:not-allowed; }
    .tl-btn:disabled:hover { background:var(--black); color:var(--yellow); }

    .tl-time { font-family:var(--font-mono); font-size:0.7rem; color:rgba(0,0,0,0.5); margin-left:auto; }

    .tl-track {
      position:relative; height:36px;
      background: rgba(0,0,0,0.08);
      border:2px solid var(--black); border-radius:4px;
      overflow:hidden; cursor:pointer;
    }

    #waveformCanvas {
      position:absolute; inset:0; width:100%; height:100%;
    }

    .tl-playhead {
      position:absolute; top:0; bottom:0; width:2px;
      background:var(--red); z-index:5; pointer-events:none;
      box-shadow:0 0 6px var(--red);
    }

    /* Keyframe markers on track */
    .tl-kf-marker {
      position:absolute; top:2px; width:4px; height:calc(100% - 4px);
      border-radius:2px; z-index:4; pointer-events:none;
    }
    .tl-kf-marker.mouth { background:var(--red); }
    .tl-kf-marker.eyes  { background:var(--blue); }
    .tl-kf-marker.blink { background:var(--yellow); }

    .tl-scrubber { width:100%; accent-color:var(--red); margin-top:0.35rem; }

    /* â”€â”€ RIGHT: Controls panel â”€â”€ */
    .controls-col {
      display: flex; flex-direction: column;
      overflow: hidden;
    }

    .ctrl-section {
      border-bottom: 3px solid var(--black);
      flex-shrink: 0;
    }

    .ctrl-hd {
      background: var(--black);
      padding: 0.5rem 1rem;
      font-family: var(--font-display); font-size:0.82rem; color:var(--yellow); letter-spacing:0.08em;
      display: flex; align-items: center; justify-content: space-between;
    }

    .ctrl-body { padding:0.75rem; }

    /* Audio section */
    .audio-btns { display:flex; gap:0.5rem; flex-wrap:wrap; margin-bottom:0.6rem; }

    .audio-btn {
      padding:0.4rem 0.75rem;
      font-family:var(--font-display); font-size:0.75rem; letter-spacing:0.06em;
      background:var(--black); color:var(--yellow);
      border:2px solid var(--black); border-radius:4px;
      cursor:pointer; transition:all 0.1s;
    }
    .audio-btn:hover  { background:var(--yellow); color:var(--black); }
    .audio-btn:active { transform:scale(0.95); }
    .audio-btn:disabled { opacity:0.35; cursor:not-allowed; }
    .audio-btn.recording { background:var(--red); color:#fff; border-color:var(--red); animation:pulse 1s infinite; }

    @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.6} }

    .audio-player-wrap { margin-top:0.5rem; }
    .audio-player-wrap audio { width:100%; height:32px; }

    /* Volume row */
    .vol-row { display:flex; align-items:center; gap:0.6rem; margin-top:0.5rem; }
    .vol-row label { font-family:var(--font-mono); font-size:0.62rem; color:rgba(0,0,0,0.5); flex-shrink:0; }
    .vol-row input[type=range] { flex:1; accent-color:var(--black); }
    .vol-val { font-family:var(--font-mono); font-size:0.62rem; color:var(--black); flex-shrink:0; width:32px; }

    /* Eyes + Mouth animate sections */
    .face-panel { flex:1; overflow-y:auto; }
    .face-panel::-webkit-scrollbar { width:5px; }
    .face-panel::-webkit-scrollbar-thumb { background:var(--black); border-radius:3px; }

    /* Lip sync toggle */
    .ls-row {
      display:flex; align-items:center; gap:0.6rem;
      margin-bottom:0.6rem;
    }
    .ls-row input[type=checkbox] { width:16px; height:16px; accent-color:var(--black); cursor:pointer; }
    .ls-row label { font-family:var(--font-display); font-size:0.75rem; letter-spacing:0.05em; color:var(--black); cursor:pointer; }

    .ctrl-select {
      width:100%; padding:0.4rem 0.6rem;
      font-family:var(--font-mono); font-size:0.7rem;
      background:#fff; color:var(--black);
      border:2px solid var(--black); border-radius:4px;
      margin-bottom:0.6rem; cursor:pointer;
    }

    .ctrl-label { font-family:var(--font-mono); font-size:0.62rem; color:rgba(0,0,0,0.5); text-transform:uppercase; letter-spacing:0.06em; margin-bottom:0.35rem; display:block; }

    .kf-add-btn {
      width:100%; padding:0.38rem;
      font-family:var(--font-display); font-size:0.75rem; letter-spacing:0.06em;
      background:var(--black); color:var(--yellow);
      border:2px solid var(--black); border-radius:4px;
      cursor:pointer; transition:all 0.1s; margin-bottom:0.75rem;
    }
    .kf-add-btn:hover  { background:var(--yellow); color:var(--black); }
    .kf-add-btn:active { transform:scale(0.97); }
    .kf-add-btn:disabled { opacity:0.35; cursor:not-allowed; }
    .kf-add-btn:disabled:hover { background:var(--black); color:var(--yellow); }

    /* Keyframe list */
    .kf-list {
      max-height: 140px; overflow-y:auto;
      background:rgba(0,0,0,0.05); border:2px solid rgba(0,0,0,0.1); border-radius:4px;
      padding:0.4rem;
    }
    .kf-list::-webkit-scrollbar { width:4px; }
    .kf-list::-webkit-scrollbar-thumb { background:var(--black); border-radius:3px; }
    .kf-empty { font-family:var(--font-mono); font-size:0.65rem; color:rgba(0,0,0,0.35); padding:0.25rem; }
    .kf-item {
      display:flex; align-items:center; justify-content:space-between;
      padding:0.3rem 0.4rem; border-radius:3px;
      background:rgba(255,255,255,0.5); border:1px solid rgba(0,0,0,0.08);
      margin-bottom:0.3rem; font-family:var(--font-mono); font-size:0.63rem; gap:0.4rem;
    }
    .kf-item:last-child { margin-bottom:0; }
    .kf-dot { width:8px; height:8px; border-radius:50%; flex-shrink:0; }
    .kf-dot.mouth { background:var(--red); }
    .kf-dot.eyes  { background:var(--blue); }
    .kf-dot.blink { background:var(--yellow); border:1px solid var(--black); }
    .kf-info { flex:1; min-width:0; }
    .kf-time { color:rgba(0,0,0,0.45); }
    .kf-name { color:var(--black); font-weight:600; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .kf-del  { background:none; border:none; color:var(--red); font-size:0.75rem; cursor:pointer; padding:0; flex-shrink:0; }
    .kf-del:hover { transform:scale(1.2); }

    /* Export section */
    .export-section { border-top:3px solid var(--black); flex-shrink:0; }
    .btn-export {
      width:100%; padding:0.7rem;
      font-family:var(--font-display); font-size:0.9rem; letter-spacing:0.06em; text-transform:uppercase;
      background:var(--green); color:var(--black);
      border:3px solid var(--black); border-radius:6px;
      cursor:pointer; box-shadow:var(--shadow-sm); transition:all 0.1s;
    }
    .btn-export:hover  { transform:translate(-2px,-2px); box-shadow:6px 6px 0 var(--black); }
    .btn-export:active { transform:translate(2px,2px); box-shadow:2px 2px 0 var(--black); }
    .btn-export:disabled { opacity:0.4; cursor:not-allowed; transform:none; box-shadow:var(--shadow-sm); }

    .export-progress { margin-top:0.65rem; display:none; }
    .exp-bar  { height:8px; background:rgba(0,0,0,0.1); border:2px solid var(--black); border-radius:999px; overflow:hidden; margin-bottom:0.35rem; }
    .exp-fill { height:100%; background:var(--green); border-radius:999px; transition:width 0.2s; }
    .exp-text { font-family:var(--font-mono); font-size:0.65rem; color:rgba(0,0,0,0.5); text-align:center; }

    .todo-note { font-family:var(--font-mono); font-size:0.58rem; color:rgba(0,0,0,0.3); font-style:italic; text-align:center; margin-top:0.4rem; }

    @media (max-width:900px) {
      .anim-wrap { grid-template-columns:1fr; grid-template-rows:auto auto; height:auto; overflow:visible; }
      .stage-col { border-right:none; border-bottom:4px solid var(--black); }
      .canvas-wrap { width:min(440px,90vw); height:min(440px,90vw); }
      .controls-col { overflow:visible; }
    }
  </style>
</head>
<body>

<nav class="bhb-nav">
  <a href="../index.html" class="logo">BIG HEAD <span>BILLIONAIRES</span></a>
  <ul class="nav-links">
    <li><a href="../game/index.html">Play &amp; Mint</a></li>
    <li><a href="../expansions/index.html">Expansions</a></li>
    <li><a href="../customizer/index.html">Customizer</a></li>
    <li><a href="index.html" class="active">Animator</a></li>
    <li><a href="../episodes/index.html">Watch</a></li>
  </ul>
  <button class="nav-wallet-btn" id="walletBtn">Connect Wallet</button>
</nav>

<div class="page-header">
  <div>
    <h1>ğŸ¬ Character Animator v1.5</h1>
    <p>Body locked from Customizer. Animate Eyes &amp; Mouth with audio.</p>
  </div>
  <a href="../customizer/index.html" style="font-family:var(--font-display);font-size:0.82rem;letter-spacing:0.06em;color:var(--yellow);text-decoration:none;opacity:0.7;">â—€ Back to Customizer</a>
</div>

<div class="anim-wrap">

  <!-- â”€â”€ LEFT: Stage â”€â”€ -->
  <div class="stage-col">
    <div class="stage-area">
      <div class="canvas-wrap">
        <canvas id="animCanvas" width="1000" height="1000"></canvas>

        <!-- Loading overlay -->
        <div class="load-overlay" id="loadOverlay">
          <div class="load-title">ğŸ” Loading Character...</div>
          <div class="load-bar"><div class="load-fill" id="loadFill" style="width:0%"></div></div>
          <div class="load-stat" id="loadStat">Starting...</div>
        </div>

        <!-- No-character gate -->
        <div class="gate-overlay" id="gateOverlay">
          <div class="gate-title">No Character Found</div>
          <div class="gate-sub">Save a character in the Customizer first,<br/>then come back here to animate it.</div>
          <a href="../customizer/index.html" class="gate-btn">ğŸ¨ Go to Customizer</a>
        </div>
      </div>
    </div>

    <!-- BG selector -->
    <div class="bg-strip">
      <span class="bg-strip-label">BG:</span>
      <button class="bg-btn active" data-bg="green"     onclick="setBg('green')">ğŸŸ¢ Green</button>
      <button class="bg-btn"        data-bg="blue"      onclick="setBg('blue')">ğŸ”µ Blue</button>
      <button class="bg-btn"        data-bg="black"     onclick="setBg('black')">âš« Black</button>
      <button class="bg-btn"        data-bg="white"     onclick="setBg('white')">âšª White</button>
      <button class="bg-btn"        data-bg="character" onclick="setBg('character')">ğŸ¨ Character</button>
    </div>

    <!-- Timeline -->
    <div class="timeline-bar">
      <div class="tl-row">
        <button class="tl-btn" id="playBtn"  onclick="togglePlay()" disabled>â–¶ Play</button>
        <button class="tl-btn" id="resetBtn" onclick="resetTimeline()" disabled>â® Reset</button>
        <span class="tl-time" id="tlTime">0.00s / 0.00s</span>
      </div>
      <div class="tl-track" id="tlTrack" onclick="scrubClick(event)">
        <canvas id="waveformCanvas"></canvas>
        <div class="tl-playhead" id="playhead" style="left:0%"></div>
        <!-- kf markers injected by JS -->
      </div>
      <input type="range" class="tl-scrubber" id="tlScrubber" min="0" max="100" step="0.1" value="0" oninput="scrubInput(this.value)" disabled/>
    </div>
  </div>

  <!-- â”€â”€ RIGHT: Controls â”€â”€ -->
  <div class="controls-col">

    <!-- Audio -->
    <div class="ctrl-section">
      <div class="ctrl-hd">ğŸ“¢ Audio</div>
      <div class="ctrl-body">
        <div class="audio-btns">
          <button class="audio-btn" id="recBtn"  onclick="startRec()">ğŸ¤ Record</button>
          <button class="audio-btn" id="stopBtn" onclick="stopRec()" disabled>â¹ Stop</button>
          <button class="audio-btn" onclick="document.getElementById('audioFile').click()">ğŸ“ Upload</button>
          <input type="file" id="audioFile" accept="audio/*" onchange="loadFile(event)" style="display:none"/>
        </div>
        <div class="audio-player-wrap">
          <audio id="audioPlayer" controls style="display:none; width:100%; height:32px;"></audio>
        </div>
        <div class="vol-row" id="volRow" style="display:none">
          <label>VOL</label>
          <input type="range" id="volSlider" min="0" max="100" value="100" oninput="setVol(this.value)"/>
          <span class="vol-val" id="volVal">100%</span>
        </div>
      </div>
    </div>

    <!-- Face animation panel -->
    <div class="face-panel">

      <!-- Lip Sync -->
      <div class="ctrl-section">
        <div class="ctrl-hd">ğŸ‘„ Mouth / Lip Sync</div>
        <div class="ctrl-body">
          <div class="ls-row">
            <input type="checkbox" id="autoSync" checked onchange="toggleAutoSync()"/>
            <label for="autoSync">ğŸ¤– Auto Lip Sync</label>
          </div>
          <div id="autoSyncSub" style="font-family:var(--font-mono);font-size:0.62rem;color:rgba(0,0,0,0.45);margin-bottom:0.65rem;">Mouth auto-drives from audio volume.</div>

          <span class="ctrl-label">Sync Style</span>
          <select class="ctrl-select" id="syncStyle">
            <option value="ehh">Ehh (default)</option>
            <option value="ooo">Ooo (rounder)</option>
          </select>

          <div id="manualMouthWrap" style="display:none">
            <span class="ctrl-label">Manual Shape</span>
            <select class="ctrl-select" id="mouthSel" onchange="previewMouth()">
              <option value="Mmm.png">Closed (Mmm)</option>
              <option value="Ahh.png">Open (Ahh)</option>
              <option value="Ooo.png">Round (Ooo)</option>
              <option value="Eee.png">Wide (Eee)</option>
              <option value="Fff.png">Lips (Fff)</option>
              <option value="LLL.png">L Sound</option>
              <option value="Thh.png">Th Sound</option>
            </select>
            <button class="kf-add-btn" onclick="addMouthKF()" id="addMouthBtn" disabled>â• Add Mouth Keyframe</button>
          </div>

          <div class="kf-list" id="mouthKFList"><div class="kf-empty">No mouth keyframes</div></div>
        </div>
      </div>

      <!-- Eyes / Blink -->
      <div class="ctrl-section">
        <div class="ctrl-hd">ğŸ‘ Eyes &amp; Expressions</div>
        <div class="ctrl-body">
          <button class="kf-add-btn" onclick="addBlinkKF()" id="addBlinkBtn" disabled>ğŸ‘ Add Blink at Playhead</button>

          <span class="ctrl-label">Expression</span>
          <select class="ctrl-select" id="eyesSel" onchange="previewEyes()">
            <option value="">â€” No override â€”</option>
            <option value="Curious.png">Curious</option>
            <option value="Surprised.png">Surprised</option>
            <option value="Joy.png">Joy</option>
            <option value="Infuriated.png">Infuriated</option>
            <option value="Ouchy.png">Ouchy</option>
            <option value="Stern.png">Stern</option>
            <option value="Grumpy.png">Grumpy</option>
            <option value="Annoyed.png">Annoyed</option>
            <option value="Paranoid.png">Paranoid</option>
            <option value="Too Chill.png">Too Chill</option>
          </select>
          <button class="kf-add-btn" onclick="addEyeKF()" id="addEyeBtn" disabled>â• Add Eye Keyframe</button>

          <div class="kf-list" id="eyesKFList"><div class="kf-empty">No eye keyframes</div></div>
        </div>
      </div>

    </div><!-- /face-panel -->

    <!-- Export -->
    <div class="export-section ctrl-section">
      <div class="ctrl-body">
        <button class="btn-export" id="exportBtn" onclick="exportVideo()" disabled>ğŸ¥ Export Video</button>
        <div class="export-progress" id="expProgress">
          <div class="exp-bar"><div class="exp-fill" id="expFill" style="width:0%"></div></div>
          <div class="exp-text" id="expText">Preparing...</div>
        </div>
        <div class="todo-note">// TODO: wire on-chain trait verification after Candy Machine deploy</div>
      </div>
    </div>

  </div><!-- /controls-col -->
</div><!-- /anim-wrap -->

<script src="../assets/bhb.js"></script>
<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BHB ANIMATOR v1.0
//  Reads character config from localStorage (set by Customizer).
//  Only EYES and MOUTH are animatable â€” all other traits are locked.
//  TODO: Replace localStorage read with Helius DAS on-chain trait fetch
//        once Candy Machine and wallet verification are in place.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const ASSET_BASE = 'https://bhaleyart.github.io/BigHeadCharacterCooker';

// â”€â”€ All trait data (same as Customizer) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const TRAITS = {
  EYES: { files:[
    'Curious.png','Alien.png','Annoyed.png','Demonic.png','Diamond.png','Dots.png',
    'Grumpy.png','Hypnotized.png','Infuriated.png','Insect.png','Joy.png',
    'Light Bright.png','Monocle.png','Ouchy.png','Paranoid.png','Possessed.png',
    'Ruby Stare.png','Spider.png','Stare.png','Stoney Eyes.png','Sunglasses.png',
    'Surprised.png','Tears.png','Deceased.png','Too Chill.png','VR Headset.png',
    '3D Glasses.png','Blink.png','Stern.png','Tears.gif'
  ]},
  MOUTH: { files:[
    'Mmm.png','Simpleton.png','Stache.png','Creeper.png','Pierced.png','Fangs.png',
    'Gold Teeth.png','Diamond Teeth.png','Birdy.png','Panic.png','Sss.png','Ahh.png',
    'Ehh.png','Uhh.png','LLL.png','Rrr.png','Fff.png','Ooo.png','Thh.png','Eee.png',
    'Haha.png','Rofl.png','Bean Frown.png','Bean Smile.png','Smirk.png','Bored.png',
    'Gas Mask.png','Scuba.png'
  ]},
  HEAD: { files:[
    'None.png','Antenna.png','Bandana Bro.png','Beanie.png','Blonde Beanie.png',
    'Blonde Bun.png','Blue Bedhead.png','Brain Squid.png','Bravo.png','Brunette Beanie.png',
    'Brunette Ponytail.png','Burger Crown.png','Captain Hat.png','Cat Hat.png',
    'Chad Bandana.png','Cherry Sundae.png','Clown Wig.png','Fancy Hat.png','Fireman.png',
    'Flame Princess.png','Fossilized.png','Gamer Girl.png','Ginger Ponytail.png',
    'Heated.png','Horny Horns.png','Hunted.png','Jester.png','Kingly.png','Mad Hatter.png',
    'Masked Up.png','Mohawk Blue.png','Mohawk Green.png','Mohawk Red.png','Mortricia.png',
    'Outlaw.png','Overload.png','Patrol Cap.png','Pharaoh Hat.png','Pink Pigtails.png',
    'Powdered Wig.png','Press Pass.png','Propeller.png','Rainbow Babe.png',
    'Recon Helmet.png','Robin Hood.png','Santa Hat.png','Sewer Slime.png',
    'Snapback Blue.png','Snapback Hippy.png','Snapback Red.png','Snapback Yellow.png',
    'Sombrero.png','Spiritual.png','Surgeon.png','UwU Kitty.png','Valhalla Cap.png',
    'Way Dizzy.png'
  ]},
  OUTFIT: { files:[
    'None.png','Blue Tee.png','Blueberry Dye.png','Degen Green.png','Degen Purple.png',
    'Earthy Dye.png','Hodl Black.png','Hodl White.png','Locked Up.png','Moto-X.png',
    'Orange Zip.png','Passion Dye.png','Pink Zip.png','Raider Ref.png','Red Tee.png',
    'Smally Bigs.png','Yellow Tee.png','Blue Zip.png','Red Zip.png','White Zip.png',
    'Hornet Zip.png','Ghostly Zip.png','Gold Jacket.png','Tuxedo.png','Thrashed.png',
    'The Fuzz.png','Pin Striped.png','Designer Zip.png','Luxury Zip.png','Explorer.png',
    'Power Armor.png','Shinobi.png','Thrilled.png','Trenches.png','Ski Jacket.png',
    'Sled Jacket.png','Commando.png','Space Cadet.png','Burgler.png','Commandant.png',
    'Golden Knight.png','Honey Bee.png','Necromancer.png','Paladin.png','Refined Suit.png',
    'Sexy Jacket.png','Stoner Hoodie.png','The Duke.png','Rave Hoodie.png',
    'Scuba suit temp.png','Burger Suit.png','Scrubs.png'
  ]},
  TEXTURE: { files:[
    'None.png','Blood.png','Acid.png','Ink.png','Dart Frog Blue.png','Dart Frog Red.png',
    'Dart Frog Yellow.png','Magical.png','Puzzled.png','Rug Life Ink.png','Pulverized.png'
  ]},
  BODY: { files:[
    'Blank.png','Charcoal.png','High Voltage.png','Nebulous.png','Pinky.png',
    'Shockwave.png','Tangerine.png','Turquoise.png','Woody.png','Frogger.png',
    'Area 51.png','Dark Tone.png','Mid Tone.png','Light Tone.png','Jolly Roger.png',
    'Cyber Punk.png','Talking Corpse.png','Day Tripper.png','Meat Lover.png',
    'Golden God.png','Chrome Dome.png','Candy Gloss.png','Man On Fire.png','Water Boy.png',
    'Icecream Man.png','Reptilian.png','Juiced Up.png','Toxic Waste.png','Love Potion.png',
    'Pop Artist.png','Autopsy.png','Ghostly.png','Blue Screen.png','Networker.png'
  ]},
  BACKGROUNDS: { files:[
    'None.png','Natural.png','Mania.png','Regal.png','Lavish.png','Sunflower.png',
    'Snowflake.png','Bleach.png','Vibes.png','Burst.png','Aquatic.png','Passionate.png',
    'Envious.png','Enlightened.png','Haunted.png','Cursed.png'
  ]}
};

const FEMALE_LAYERS = {
  EYELASHES: { folder:'GIRL', files:['Eyelashes.png'] },
  BREASTS:   { folder:'GIRL', files:['Breasts.png'] }
};

// Render order bottom â†’ top (EYES and MOUTH driven by animator)
const LAYER_ORDER = ['BACKGROUNDS','BODY','TEXTURE','OUTFIT','BREASTS','HEAD','MOUTH','EYELASHES','EYES'];

// â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const S = {
  indices:    {},    // saved from customizer
  images:     {},    // loaded images
  female:     false,
  bgMode:     'green',
  // Audio
  audioBuffer:  null,
  audioDuration: 0,
  currentTime:  0,
  playing:      false,
  audioCtx:     null,
  waveformData: null,
  // Animation
  autoLipSync: true,
  keyframes:   [],   // {time, type:'mouth'|'eyes'|'blink', value, duration?}
  // Eye/mouth preview overrides (while not playing)
  previewEyes:  null,
  previewMouth: null
};

// Audio elements
const audioEl = document.getElementById('audioPlayer');
let animRAF = null;
let mediaRec = null;

// â”€â”€ Load character config from localStorage â”€â”€
function loadConfig() {
  try {
    const raw = localStorage.getItem('bhb_character');
    if (!raw) return false;
    const cfg = JSON.parse(raw);
    if (cfg.indices) {
      Object.entries(cfg.indices).forEach(([cat, idx]) => { S.indices[cat] = Number(idx); });
    }
    S.female = !!cfg.female;
    return true;
  } catch(e) { return false; }
}

// Default indices (None where possible)
Object.keys(TRAITS).forEach(cat => {
  const none = TRAITS[cat].files.findIndex(f => f.toLowerCase() === 'none.png');
  S.indices[cat] = none >= 0 ? none : 0;
  S.images[cat]  = [];
});
Object.keys(FEMALE_LAYERS).forEach(cat => {
  S.indices[cat] = 0;
  S.images[cat]  = [];
});

const hasConfig = loadConfig();

// â”€â”€ Canvas â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('animCanvas');
const ctx    = canvas.getContext('2d');

// â”€â”€ Preload assets â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function preloadAll() {
  const fill = document.getElementById('loadFill');
  const stat = document.getElementById('loadStat');
  const jobs = [];

  Object.entries(TRAITS).forEach(([cat, def]) => {
    def.files.forEach((file, idx) => jobs.push({ cat, folder:cat, file, idx }));
  });
  Object.entries(FEMALE_LAYERS).forEach(([cat, def]) => {
    def.files.forEach((file, idx) => jobs.push({ cat, folder:def.folder, file, idx }));
  });

  let done = 0;
  const total = jobs.length;

  await Promise.all(jobs.map(({ cat, folder, file, idx }) =>
    new Promise(resolve => {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = img.onerror = () => {
        S.images[cat][idx] = (img.complete && img.naturalWidth) ? img : null;
        fill.style.width = Math.round(++done / total * 100) + '%';
        stat.textContent  = `${done} / ${total}`;
        resolve();
      };
      img.src = `${ASSET_BASE}/${folder}/${encodeURIComponent(file)}`;
    })
  ));

  document.getElementById('loadOverlay').style.display = 'none';

  if (!hasConfig) {
    document.getElementById('gateOverlay').classList.add('show');
  }

  renderFrame(0, null, null);
}

// â”€â”€ Render a single frame â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// eyesFile and mouthFile override the saved indices when provided
function renderFrame(time, eyesFile, mouthFile) {
  ctx.clearRect(0, 0, 1000, 1000);

  // Background
  if (S.bgMode !== 'character') {
    const colors = { green:'#00ff00', blue:'#0000ff', black:'#000000', white:'#ffffff' };
    ctx.fillStyle = colors[S.bgMode] ?? '#00ff00';
    ctx.fillRect(0, 0, 1000, 1000);
  }

  for (const cat of LAYER_ORDER) {
    if (FEMALE_LAYERS[cat] && !S.female) continue;

    let idx = S.indices[cat] ?? 0;

    // Override MOUTH
    if (cat === 'MOUTH') {
      const mf = mouthFile ?? getMouthAtTime(time);
      if (mf) {
        const mi = TRAITS.MOUTH.files.indexOf(mf);
        if (mi >= 0) idx = mi;
      }
    }

    // Override EYES
    if (cat === 'EYES') {
      const ef = eyesFile ?? getEyesAtTime(time);
      if (ef) {
        const ei = TRAITS.EYES.files.indexOf(ef);
        if (ei >= 0) idx = ei;
      }
    }

    // Skip background layer if using character bg
    if (cat === 'BACKGROUNDS' && S.bgMode !== 'character') continue;

    const img = S.images[cat]?.[idx];
    if (img) ctx.drawImage(img, 0, 0, 1000, 1000);
  }
}

// â”€â”€ Get mouth shape at time â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getMouthAtTime(time) {
  // 1. Manual keyframe takes priority
  let kfMouth = null;
  for (const kf of S.keyframes) {
    if (kf.type === 'mouth' && kf.time <= time) kfMouth = kf.value;
  }
  if (kfMouth) return kfMouth;

  // 2. Auto lip sync
  if (S.autoLipSync && S.audioBuffer) {
    const vol = getVolumeAt(time);
    const style = document.getElementById('syncStyle').value;
    const mid = style === 'ooo' ? 'Ooo.png' : 'Ehh.png';
    if (vol > 0.12) return 'Ahh.png';
    if (vol > 0.05) return mid;
    if (vol > 0.02) return 'Eee.png';
    return 'Mmm.png';
  }

  return null; // use saved index
}

// â”€â”€ Get eyes at time â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getEyesAtTime(time) {
  let activeEyes = null;
  for (const kf of S.keyframes) {
    if (kf.type === 'blink') {
      const end = kf.time + (kf.duration ?? 0.12);
      if (time >= kf.time && time < end) return 'Blink.png';
    }
    if (kf.type === 'eyes' && kf.time <= time) activeEyes = kf.value;
  }
  return activeEyes;
}

// â”€â”€ Volume at time â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getVolumeAt(time) {
  if (!S.audioBuffer) return 0;
  const sr  = S.audioBuffer.sampleRate;
  const pos = Math.floor(time * sr);
  const win = Math.floor(sr * 0.02);
  const ch  = S.audioBuffer.getChannelData(0);
  let sum = 0;
  for (let i = 0; i < win && pos + i < ch.length; i++) sum += Math.abs(ch[pos + i]);
  return sum / win;
}

// â”€â”€ Background â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setBg(mode) {
  S.bgMode = mode;
  document.querySelectorAll('.bg-btn').forEach(b => b.classList.toggle('active', b.dataset.bg === mode));
  renderFrame(S.currentTime, S.previewEyes, S.previewMouth);
}

// â”€â”€ Audio: record â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startRec() {
  navigator.mediaDevices.getUserMedia({ audio:true }).then(stream => {
    const chunks = [];
    // Pick best supported audio format
    const mimeType = ['audio/webm;codecs=opus','audio/webm','audio/ogg;codecs=opus','audio/mp4']
      .find(m => MediaRecorder.isTypeSupported(m)) || '';
    mediaRec = mimeType ? new MediaRecorder(stream, { mimeType }) : new MediaRecorder(stream);
    mediaRec.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };
    mediaRec.onstop = () => {
      const actualType = mediaRec.mimeType || mimeType || 'audio/webm';
      mediaRec = null;  // Safe to null now â€” mimeType already captured
      const blob = new Blob(chunks, { type: actualType });
      loadAudioBlob(blob);
      stream.getTracks().forEach(t => t.stop());
    };
    mediaRec.start(100);
    document.getElementById('recBtn').classList.add('recording');
    document.getElementById('recBtn').textContent = 'âº Recording...';
    document.getElementById('stopBtn').disabled = false;
  }).catch(e => BHB.toast('Mic access denied: ' + e.message, 'error'));
}

function stopRec() {
  if (mediaRec) {
    mediaRec.stop();
    // Don't null mediaRec here â€” onstop fires async and still needs mediaRec.mimeType.
    // It nulls itself inside onstop after the blob is built.
  }
  const rb = document.getElementById('recBtn');
  rb.classList.remove('recording');
  rb.textContent = 'ğŸ¤ Record';
  document.getElementById('stopBtn').disabled = true;
}

function loadFile(e) {
  const file = e.target.files[0];
  if (file) loadAudioBlob(file);
}

function loadAudioBlob(blob) {
  audioEl.style.display = 'block';
  audioEl.volume = 1;
  document.getElementById('volRow').style.display = 'flex';

  // Set <audio> src for playback
  if (S._prevAudioUrl) URL.revokeObjectURL(S._prevAudioUrl);
  const url = URL.createObjectURL(blob);
  S._prevAudioUrl = url;
  audioEl.src = url;
  audioEl.load();

  // Use FileReader to get ArrayBuffer for WebAudio decoding.
  // We read the original blob â€” NOT the object URL â€” to avoid
  // cross-origin restrictions that block fetch() on blob: URLs in some browsers.
  const reader = new FileReader();
  reader.onload = async ev => {
    try {
      if (!S.audioCtx) S.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (S.audioCtx.state === 'suspended') await S.audioCtx.resume();

      // slice(0) clones the buffer â€” decodeAudioData consumes its input
      const buf = await S.audioCtx.decodeAudioData(ev.target.result.slice(0));

      S.audioBuffer   = buf;
      S.audioDuration = buf.duration;

      drawWaveform();
      unlockTimeline();
      BHB.toast('Audio loaded âœ“', 'success');
    } catch(e) {
      BHB.toast('Audio decode failed: ' + e.message, 'error');
      console.error('decodeAudioData error:', e);
    }
  };
  reader.onerror = () => BHB.toast('Could not read audio file', 'error');
  reader.readAsArrayBuffer(blob);
}

// â”€â”€ Waveform â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawWaveform() {
  const wc  = document.getElementById('waveformCanvas');
  const track = document.getElementById('tlTrack');
  wc.width  = track.offsetWidth  || 600;
  wc.height = track.offsetHeight || 36;
  const wCtx = wc.getContext('2d');

  const data = S.audioBuffer.getChannelData(0);
  const W = wc.width, H = wc.height;
  const bSize = Math.floor(data.length / W);

  wCtx.clearRect(0, 0, W, H);
  wCtx.fillStyle = 'rgba(0,0,0,0.08)';
  wCtx.fillRect(0, 0, W, H);

  for (let i = 0; i < W; i++) {
    let sum = 0;
    for (let j = 0; j < bSize; j++) sum += Math.abs(data[i * bSize + j]);
    const amp = (sum / bSize) * H * 0.9;
    wCtx.fillStyle = 'rgba(0,0,0,0.45)';
    wCtx.fillRect(i, (H - amp) / 2, 1, amp);
  }
}

// â”€â”€ Timeline unlock â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Named handlers so we can remove them before re-adding on subsequent loads
function _onTimeUpdate() {
  S.currentTime = audioEl.currentTime;
  updatePlayhead();
  renderFrame(S.currentTime, null, null);
}
function _onEnded() {
  S.playing = false;
  document.getElementById('playBtn').textContent = 'â–¶ Play';
}

function unlockTimeline() {
  ['playBtn','resetBtn','addMouthBtn','addBlinkBtn','addEyeBtn','exportBtn'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.disabled = false;
  });
  document.getElementById('tlScrubber').disabled = false;
  document.getElementById('tlScrubber').max = S.audioDuration;
  updateTimeDisplay();

  // Remove before adding â€” prevents duplicate listeners on re-record / re-upload
  audioEl.removeEventListener('timeupdate', _onTimeUpdate);
  audioEl.removeEventListener('ended', _onEnded);
  audioEl.addEventListener('timeupdate', _onTimeUpdate);
  audioEl.addEventListener('ended', _onEnded);
}

// â”€â”€ Playback â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function togglePlay() {
  if (!S.audioBuffer) return;
  if (S.playing) {
    audioEl.pause();
    S.playing = false;
    document.getElementById('playBtn').textContent = 'â–¶ Play';
  } else {
    audioEl.play().catch(() => BHB.toast('Could not play audio', 'error'));
    S.playing = true;
    document.getElementById('playBtn').textContent = 'â¸ Pause';
  }
}

function resetTimeline() {
  audioEl.pause();
  audioEl.currentTime = 0;
  S.currentTime = 0;
  S.playing = false;
  document.getElementById('playBtn').textContent = 'â–¶ Play';
  document.getElementById('tlScrubber').value = 0;
  updatePlayhead();
  updateTimeDisplay();
  renderFrame(0, null, null);
}

function scrubInput(val) {
  const t = parseFloat(val);
  S.currentTime = t;
  audioEl.currentTime = t;
  updatePlayhead();
  updateTimeDisplay();
  renderFrame(t, null, null);
}

function scrubClick(e) {
  if (!S.audioDuration) return;
  const rect = e.currentTarget.getBoundingClientRect();
  const pct  = (e.clientX - rect.left) / rect.width;
  const t    = pct * S.audioDuration;
  scrubInput(t);
  document.getElementById('tlScrubber').value = t;
}

function updatePlayhead() {
  const pct = S.audioDuration ? (S.currentTime / S.audioDuration * 100) : 0;
  document.getElementById('playhead').style.left = pct + '%';
  document.getElementById('tlScrubber').value = S.currentTime;
  updateTimeDisplay();
  refreshKFMarkers();
}

function updateTimeDisplay() {
  document.getElementById('tlTime').textContent =
    `${S.currentTime.toFixed(2)}s / ${S.audioDuration.toFixed(2)}s`;
}

// â”€â”€ Volume â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setVol(v) {
  audioEl.volume = v / 100;
  document.getElementById('volVal').textContent = v + '%';
}

// â”€â”€ Lip sync toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function toggleAutoSync() {
  S.autoLipSync = document.getElementById('autoSync').checked;
  document.getElementById('manualMouthWrap').style.display = S.autoLipSync ? 'none' : 'block';
  document.getElementById('autoSyncSub').style.display     = S.autoLipSync ? 'block' : 'none';
  renderFrame(S.currentTime, null, null);
}

// â”€â”€ Previews â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function previewMouth() {
  if (!S.autoLipSync) {
    S.previewMouth = document.getElementById('mouthSel').value;
    renderFrame(S.currentTime, S.previewEyes, S.previewMouth);
  }
}

function previewEyes() {
  S.previewEyes = document.getElementById('eyesSel').value || null;
  renderFrame(S.currentTime, S.previewEyes, S.previewMouth);
}

// â”€â”€ Add keyframes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function addMouthKF() {
  const val = document.getElementById('mouthSel').value;
  S.keyframes.push({ time: S.currentTime, type: 'mouth', value: val });
  sortKF(); renderKFLists(); refreshKFMarkers();
}

function addBlinkKF() {
  S.keyframes.push({ time: S.currentTime, type: 'blink', value: 'Blink.png', duration: 0.12 });
  sortKF(); renderKFLists(); refreshKFMarkers();
}

function addEyeKF() {
  const val = document.getElementById('eyesSel').value;
  if (!val) { BHB.toast('Select an expression first', 'warning'); return; }
  // Auto-add a blink just before the expression change
  const blinkTime = Math.max(0, S.currentTime - 0.1);
  const hasBlink  = S.keyframes.some(k => k.type === 'blink' && Math.abs(k.time - blinkTime) < 0.05);
  if (!hasBlink) S.keyframes.push({ time: blinkTime, type:'blink', value:'Blink.png', duration:0.12 });
  S.keyframes.push({ time: S.currentTime, type:'eyes', value: val });
  sortKF(); renderKFLists(); refreshKFMarkers();
}

function deleteKF(idx) {
  S.keyframes.splice(idx, 1);
  sortKF(); renderKFLists(); refreshKFMarkers();
}

function sortKF() { S.keyframes.sort((a,b) => a.time - b.time); }

// â”€â”€ Render keyframe lists â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderKFLists() {
  const mList = document.getElementById('mouthKFList');
  const eList = document.getElementById('eyesKFList');
  const mKFs  = S.keyframes.map((k,i) => ({k,i})).filter(({k}) => k.type === 'mouth');
  const eKFs  = S.keyframes.map((k,i) => ({k,i})).filter(({k}) => k.type === 'eyes' || k.type === 'blink');

  mList.innerHTML = mKFs.length ? '' : '<div class="kf-empty">No mouth keyframes</div>';
  mKFs.forEach(({k,i}) => {
    const el = document.createElement('div');
    el.className = 'kf-item';
    el.innerHTML = `
      <div class="kf-dot mouth"></div>
      <div class="kf-info">
        <span class="kf-time">${k.time.toFixed(2)}s</span>
        <span class="kf-name"> â€” ${k.value.replace(/\.(png|gif)$/i,'')}</span>
      </div>
      <button class="kf-del" onclick="deleteKF(${i})">âœ•</button>
    `;
    mList.appendChild(el);
  });

  eList.innerHTML = eKFs.length ? '' : '<div class="kf-empty">No eye keyframes</div>';
  eKFs.forEach(({k,i}) => {
    const el = document.createElement('div');
    el.className = 'kf-item';
    const dotClass = k.type === 'blink' ? 'blink' : 'eyes';
    el.innerHTML = `
      <div class="kf-dot ${dotClass}"></div>
      <div class="kf-info">
        <span class="kf-time">${k.time.toFixed(2)}s</span>
        <span class="kf-name"> â€” ${k.value.replace(/\.(png|gif)$/i,'')}</span>
      </div>
      <button class="kf-del" onclick="deleteKF(${i})">âœ•</button>
    `;
    eList.appendChild(el);
  });
}

// â”€â”€ Keyframe markers on timeline track â”€â”€â”€â”€â”€â”€â”€â”€
function refreshKFMarkers() {
  const track = document.getElementById('tlTrack');
  track.querySelectorAll('.tl-kf-marker').forEach(m => m.remove());
  if (!S.audioDuration) return;
  S.keyframes.forEach(k => {
    const m = document.createElement('div');
    m.className = `tl-kf-marker ${k.type}`;
    m.style.left = (k.time / S.audioDuration * 100) + '%';
    track.appendChild(m);
  });
}

// â”€â”€ Export video â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function exportVideo() {
  if (!S.audioBuffer) { BHB.toast('Load audio first!', 'error'); return; }

  const expBtn  = document.getElementById('exportBtn');
  const expProg = document.getElementById('expProgress');
  const expFill = document.getElementById('expFill');
  const expText = document.getElementById('expText');

  expBtn.disabled = true;
  expProg.style.display = 'block';
  expFill.style.width   = '0%';
  expText.textContent   = 'Preparing...';

  try {

  audioEl.pause();
  audioEl.currentTime = 0;
  S.currentTime = 0;

  renderFrame(0, null, null);
  await new Promise(r => requestAnimationFrame(r));

  if (S.audioCtx.state === 'suspended') await S.audioCtx.resume();

  const FPS   = 30;
  const W     = canvas.width;
  const H     = canvas.height;
  const total = Math.ceil(S.audioDuration * FPS);

  // â”€â”€ Load mp4-muxer if not already loaded â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (!window.Mp4Muxer) {
    try {
      await new Promise((resolve, reject) => {
        const s   = document.createElement('script');
        s.src     = 'https://cdn.jsdelivr.net/npm/mp4-muxer@4/build/mp4-muxer.js';
        s.onload  = resolve;
        s.onerror = reject;
        document.head.appendChild(s);
      });
    } catch(e) {
      BHB.toast('Could not load MP4 encoder â€” check connection', 'error');
      expBtn.disabled = false; expProg.style.display = 'none'; return;
    }
  }

  let sampleRate = S.audioBuffer.sampleRate;
  let numCh      = S.audioBuffer.numberOfChannels;

  // If mono, duplicate to stereo â€” AAC encoder on some browsers rejects mono
  let audioBuffer = S.audioBuffer;
  if (numCh === 1) {
    const offCtx = new OfflineAudioContext(2, audioBuffer.length, sampleRate);
    const src = offCtx.createBufferSource();
    // Create stereo buffer from mono
    const stereoBuf = offCtx.createBuffer(2, audioBuffer.length, sampleRate);
    const monoData  = audioBuffer.getChannelData(0);
    stereoBuf.copyToChannel(monoData, 0);
    stereoBuf.copyToChannel(monoData, 1);
    src.buffer = stereoBuf;
    src.connect(offCtx.destination);
    src.start();
    audioBuffer = await offCtx.startRendering();
    numCh = 2;
  }
  // Always keep S.audioBuffer in sync â€” lip sync reads from it
  S.audioBuffer = audioBuffer;

  const { Muxer, ArrayBufferTarget } = window.Mp4Muxer;
  const target = new ArrayBufferTarget();
  const muxer  = new Muxer({
    target,
    video: { codec: 'avc', width: W, height: H },
    audio: { codec: 'aac', sampleRate, numberOfChannels: numCh },
    fastStart: 'in-memory'
  });

  // â”€â”€ Video encoder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const videoEncoder = new VideoEncoder({
    output: (chunk, meta) => muxer.addVideoChunk(chunk, meta),
    error:  e => { throw e; }
  });
  videoEncoder.configure({
    codec: 'avc1.42001f', width: W, height: H,
    bitrate: 5_000_000, framerate: FPS
  });

  // â”€â”€ Audio encoder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Verify AAC encoding is supported before configuring
  const aacSupport = await AudioEncoder.isConfigSupported({
    codec: 'mp4a.40.2', sampleRate, numberOfChannels: numCh, bitrate: 128_000
  });
  if (!aacSupport.supported) throw new Error('AAC encoding not supported in this browser');

  let audioChunkCount = 0;
  const audioEncoder = new AudioEncoder({
    output: (chunk, meta) => { audioChunkCount++; muxer.addAudioChunk(chunk, meta); },
    error:  e => { throw e; }
  });
  audioEncoder.configure({
    codec: 'mp4a.40.2', sampleRate,
    numberOfChannels: numCh, bitrate: 128_000
  });

  // â”€â”€ Encode audio first â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  expText.textContent = 'Encoding audio...';
  const frameSize    = 4096;  // Larger frames = fewer iterations = less overhead
  const totalSamples = audioBuffer.length;  // use the (possibly upmixed) buffer
  const totalFrames  = Math.ceil(totalSamples / frameSize);

  for (let offset = 0; offset < totalSamples; offset += frameSize) {
    const count = Math.min(frameSize, totalSamples - offset);

    // f32-planar: [ch0_block][ch1_block]
    const buf = new Float32Array(numCh * count);
    for (let ch = 0; ch < numCh; ch++) {
      buf.set(audioBuffer.getChannelData(ch).subarray(offset, offset + count), ch * count);
    }
    const audioFrame = new AudioData({
      format: 'f32-planar', sampleRate,
      numberOfFrames: count, numberOfChannels: numCh,
      timestamp: Math.round(offset / sampleRate * 1_000_000),
      data: buf
    });
    audioEncoder.encode(audioFrame);
    audioFrame.close();

    // Yield every frame AND wait for encoder queue to drain so we don't block
    while (audioEncoder.encodeQueueSize > 5) {
      await new Promise(r => setTimeout(r, 0));
    }
    await new Promise(r => setTimeout(r, 0));

    // Update progress during audio encode
    const audioPct = Math.round(offset / totalSamples * 30); // audio = first 30% of bar
    expFill.style.width = audioPct + '%';
    expText.textContent = `Encoding audio: ${Math.round(offset / totalSamples * 100)}%`;
  }
  await audioEncoder.flush();
  console.log(`Audio encoded: ${audioChunkCount} AAC chunks`);
  if (audioChunkCount === 0) throw new Error('Audio encoder produced no output â€” AAC may not be supported. Check browser console.');

  // â”€â”€ Encode video frames â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Use an OffscreenCanvas to avoid createImageBitmap stalls on the live canvas
  const exportOffscreen = new OffscreenCanvas(W, H);
  const exportOffCtx    = exportOffscreen.getContext('2d');

  for (let f = 0; f < total; f++) {
    const t = f / FPS;
    S.currentTime = t;
    renderFrame(t, null, null);

    // Copy from main canvas to offscreen â€” avoids browser compositor stalls
    exportOffCtx.drawImage(canvas, 0, 0);

    expFill.style.width = (30 + Math.round(f / total * 70)) + '%';
    expText.textContent = `Encoding video: ${Math.round(f / total * 100)}%`;

    const frame = new VideoFrame(exportOffscreen, {
      timestamp: Math.round(t * 1_000_000),
      duration:  Math.round(1_000_000 / FPS)
    });
    videoEncoder.encode(frame, { keyFrame: f % (FPS * 2) === 0 });
    frame.close();

    // Drain video encoder queue to prevent stalls
    while (videoEncoder.encodeQueueSize > 10) {
      await new Promise(r => setTimeout(r, 0));
    }
    // Yield every 5 frames
    if (f % 5 === 0) await new Promise(r => setTimeout(r, 0));
  }
  await videoEncoder.flush();

  // â”€â”€ Mux and download â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  expFill.style.width = '100%';
  expText.textContent = 'Muxing MP4...';
  muxer.finalize();

  const blob = new Blob([target.buffer], { type: 'video/mp4' });
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement('a');
  a.href     = url;
  a.download = `BHB-anim-${Date.now()}.mp4`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  setTimeout(() => URL.revokeObjectURL(url), 2000);

    expProg.style.display = 'none';
    expBtn.disabled = false;
    BHB.toast('Exported as MP4!', 'success');
  } catch(err) {
    console.error('Export failed:', err);
    BHB.toast('Export failed: ' + err.message, 'error');
    expProg.style.display = 'none';
    expBtn.disabled = false;
  }
}
// â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
preloadAll();
</script>
</body>
</html>
